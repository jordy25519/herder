#!/bin/ruby
require 'active_support/inflector'
require 'yaml'

@herds = Hash.new
@file = 'data.yaml'

# Interperet terminal commands.
def interperet
	cmd = ARGV[0]
	case (cmd)
		when '-b','--build' then build
		when '-c','--create' then create
		when '--clean' then clean
		when '--help',nil then help
		when '-l','--list' then list
		when '-r','--run' then run
		when '-s','--bench' then benchmark
		else puts "Command: \"#{cmd}\" is unrecognized."
	end
end

# Log and collect resource usage stats on herd start up.
def benchmark
	herd_name = ARGV[1]
	
	unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	end

  `systemctl restart docker`

	# Start containers.
	@herds[herd_name]["ids"].each do |id|
	  `docker start #{id}`
		puts "docker start #{id}"
	end
	# Sleep and give docker daemon time to create directory structures.
  5.times do |i|
  	puts "#{10 - i}"
  	sleep 1
  end

	Dir.chdir("/sys/fs/cgroup/memory/system.slice/")
	containers = Dir.glob("docker-*.scope")
	Dir.chdir("/home/jordan/Projects/herder/")
	threads = []
	n = 0
	containers.each do |c|
		puts "Started stats collection for container #{n} id:#{c}"
		id = c[/docker-(.*).scope/, 1].to_s
		threads << Thread.new{
			while(system("docker logs #{id} | tail -n3 | grep 'Aviarc startup complete'"))
				puts "logging #{herd_name}#{n}"
				file = "/sys/fs/cgroup/memory/system.slice/#{c}/memory.stat"
				stats = `cat #{file}`
				File.open("#{herd_name}#{n}", "a") do |f|
					f.puts
					f.puts Time.now.to_s
					f.puts stats
				end
				sleep 2
			end}
		n+=1
	end
	
	# Wait for all threads to finish.
	threads.each {|t| t.join}
  puts "Benchmarking complete."

end

# Build an image from dockerfile.
def build
	image_name = ARGV[1]
	docker_file_path = ARGV[2]

	cmd = "docker build --rm=true --tag=\"#{image_name}\" #{docker_file_path}"
	puts "Building image..."
	`#{cmd}`
	puts cmd
end

# Clean all docker containers.
def clean
 puts "Cleaning herds..."
 File.open(@file, 'w') {}
 exec("docker rm -f `docker ps --no-trunc -aq`")
end

# Instantiate a herd of docker containers.
def create
	image = ARGV[1]
	size = ARGV[2].to_i
	run_args = ARGV.drop(3).join(" ")
	
	# Convert image name to herd name.
	friendly_name = image
	friendly_name = /(?<=\/)\w+\b/.match(image).to_s if image.include?("/")
	herd_name = friendly_name.pluralize

	# Create herd data.
	@herds[herd_name] = Hash["size" => size, "ids" => Array.new]

	puts "Creating herd..."
	size.times do |n|
		cmd = "docker create --restart=always --name #{friendly_name}#{n} #{image} #{run_args}"
		@herds[herd_name]["ids"][n] = `#{cmd}`
		puts cmd
	end
	commit_data
end

# Run a command against a herd.
def run
	herd_name = ARGV[1]
	cmd = "docker " << ARGV[2]
	args = ARGV.drop(3).join(" ")
	
	unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	end

	@herds[herd_name]["ids"].each do |id|
	  `#{cmd} #{id} #{args}`
		puts "#{cmd} #{id} #{args}"
	end
end

# Write herd data to file for persistence.
def commit_data
	File.open(@file, 'w') { |file| YAML.dump(@herds, file)  }
end

# Load herd data from file.
# If file is blank or missing - intialise new hash instead.
def load_data
	if File.exists?(@file) and not File.zero?(@file)
		@herds = YAML.load_file("data.yaml") 
	else
		@herds = Hash.new
	end
end

# Print help commands.
def help
	puts "
 ___________
 < Herder >
 -----------
       \\   ^__^
        \\  (oo)\\_______
           (__)\\       )\\/\\
                ||----w |
                ||     ||"
	puts "Build a Dockerfile:"
	puts "  herder -b <repository/image_name> <path_to_dockerfile>"
	puts ""
	puts "Clean all Docker containers:"
	puts "  herder --clean"
	puts ""
	puts "Create a new herd:"
	puts "  herder -c <repository/image_name> <count>"
	puts ""
	puts "List herds:"
	puts " herder -l"
	puts ""
	puts "Run command over a herd:"
  puts "  herder -r <herd_name> <docker_command>"
	puts ""
end

def list
	puts "Herds: "	
	@herds.keys.each do |h|
		puts " #{h}, size: #{@herds[h]["size"]}"
	end
end

##################
# Run the Script.#
##################
load_data
interperet
