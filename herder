#!/bin/ruby
require 'active_support/inflector'
require 'fileutils'
require 'yaml'
require './lib/ext/string'

@herds = Hash.new
@file = 'data.yaml'

# Interperet terminal commands.
def interperet
	cmd = ARGV[0]
	case (cmd)
		when '-b','--build' then build
		when '-c','--create' then create
		when '--clean' then clean
		when '--help',nil then help
		when '-l','--list' then list
		when '-r','--run' then run
		when '-s','--bench' then benchmark
		else puts "Command: \"#{cmd}\" is unrecognized."
	end
end

# Log and collect resource usage stats on herd start up.
def benchmark
	herd_name = ARGV[1]
	pids = Hash.new
	
	unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	end

	# Start containers.
	@herds[herd_name]["ids"].each do |id|
	  `docker start #{id}`
	  sleep 2
	  # Find the Pid of the docker container.
		pids[id] = `docker inspect -f '{{ .State.Pid }}' #{id}`.chomp
		puts "docker start #{id} Pid: #{pids[id]}"
	end
  
  # Get cgroup folders.
	#Dir.chdir("/sys/fs/cgroup/blkio/system.slice/")
	#containers = Dir.glob("docker-*.scope")
	#Dir.chdir("/home/jordan/Projects/herder/")
	
	# Create folder for test run.
	run = Time.now.strftime "%D %H:%M"
	FileUtils.mkdir run
	threads = []
	n = 0
	@herds[herd_name]["ids"].each do |id|
		puts "Started stats collection for container #{n} id:#{id}"

		# Mount fs for container logs instead of calling API?
		# Stream log file + grep
		threads << Thread.new(id, n, pids[id], Time.now.sec){|id, n, pid, start|
			until(%x[docker logs --tail=3 #{id}].include? 'Aviarc startup complete')
				blkio_service_bytes = `cat /sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_service_bytes`.to_csv
				blkio_serviced = `cat /sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_serviced`.to_csv
				blkio_queued = `cat /sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_queued`.to_csv
        proc_io = `sudo cat /proc/#{pid}/io`.to_csv
        
        # proc_status = `grep -Po "(?<=State:\t)[A-Z]" /proc/#{pid}/status`.chomp
				File.open("#{run}/#{herd_name}#{n}", "a") do |f|
					time = Time.now.sec - start
					f.puts "#{time},#{proc_io},#{blkio_service_bytes},#{blkio_serviced},#{blkio_queued}"
				end
			end
			puts "Thread #{n} exited."
		}
		n+=1
	end
	
	# Wait for all threads to finish.
	threads.each {|t| t.join}
  puts "Benchmarking complete."
  
end

# Build an image from dockerfile.
def build
	image_name = ARGV[1]
	docker_file_path = ARGV[2]

	cmd = "docker build --rm=true --tag=\"#{image_name}\" #{docker_file_path}"
	puts "Building image..."
	`#{cmd}`
	puts cmd
end

# Clean all docker containers.
def clean
 puts "Cleaning herds..."
 File.open(@file, 'w') {}
 exec("docker rm -f `docker ps --no-trunc -aq`")
end

# Instantiate a herd of docker containers.
def create
	image = ARGV[1]
	size = ARGV[2].to_i
	run_args = ARGV.drop(3).join(" ")
	
	# Convert image name to herd name.
	friendly_name = image
	friendly_name = /(?<=\/)\w+\b/.match(image).to_s if image.include?("/")
	herd_name = friendly_name.pluralize

	# Create herd data.
	@herds[herd_name] = Hash["size" => size, "ids" => Array.new]

	puts "Creating herd..."
	size.times do |n|
		cmd = "docker create --restart=always --name #{friendly_name}#{n} #{image} #{run_args}"
		@herds[herd_name]["ids"][n] = `#{cmd}`
		puts cmd
	end
	commit_data
end

# Run a command against a herd.
def run
	herd_name = ARGV[1]
	cmd = "docker " << ARGV[2]
	args = ARGV.drop(3).join(" ")
	
	unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	end

	@herds[herd_name]["ids"].each do |id|
	  `#{cmd} #{id} #{args}`
		puts "#{cmd} #{id} #{args}"
	end
end

# Write herd data to file for persistence.
def commit_data
	File.open(@file, 'w') { |file| YAML.dump(@herds, file)  }
end

# Load herd data from file.
# If file is blank or missing - intialise new hash instead.
def load_data
	if File.exists?(@file) and not File.zero?(@file)
		@herds = YAML.load_file("data.yaml") 
	else
		@herds = Hash.new
	end
end

# Print help commands.
def help
	puts "
 ___________
 < Herder >
 -----------
       \\   ^__^
        \\  (oo)\\_______
           (__)\\       )\\/\\
                ||----w |
                ||     ||"
	puts "Build a Dockerfile:"
	puts "  herder -b <repository/image_name> <path_to_dockerfile>"
	puts ""
	puts "Clean all Docker containers:"
	puts "  herder --clean"
	puts ""
	puts "Create a new herd:"
	puts "  herder -c <repository/image_name> <count>"
	puts ""
	puts "List herds:"
	puts " herder -l"
	puts ""
	puts "Run command over a herd:"
  puts "  herder -r <herd_name> <docker_command>"
	puts ""
end

def list
	puts "Herds: "	
	@herds.keys.each do |h|
		puts " #{h}, size: #{@herds[h]["size"]}"
	end
end

##################
# Run the Script.#
##################
load_data
interperet
