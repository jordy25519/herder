#!/bin/ruby
require 'fileutils'
require 'yaml'
require './lib/ext/string'
require './lib/tasks/postprocess'

@herds = Hash.new
@file = 'data.yaml'

# Interperet terminal commands.
def interperet
	cmd = ARGV[0]
	case (cmd)
		when '-b','--build' then build
		when '-c','--create' then create
		when '--clean' then clean
		when '--help',nil then help
		when '-l','--list' then list
		when '-r','--run' then run
		when '-s','--bench' then benchmark
		when '-p' then process
		else puts "Command: \"#{cmd}\" is unrecognized."
	end
end

# Log and collect resource usage stats on herd start up.
def benchmark
	herd_name = ARGV[1]
	dirty = (ARGV[2] === nil)
	type = ARGV[3]
  pids = Hash.new
	
  unless dirty
    clean
    create
    herd_name = herd_name + "s"
  else
   unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	 end
  end
  
  # Create folder for test run.
	run = herd_name + "_size" + @herds[herd_name]["size"].to_s + "_" + (Time.now.strftime "date%F_time%H-%M")
	FileUtils.mkdir_p "tests/#{run}"

	threads = []
	@herds[herd_name]["ids"].each_with_index do |id, n|
	 	system("docker start #{id}")
		pids[id] = `docker inspect -f '{{ .State.Pid }}' #{id}`.chomp
		puts "docker start #{id} Pid: #{pids[id]}"
		puts "Starting stats collection for container #{n} id:#{id}"

		threads << Thread.new(id.chomp, n, pids[id]){|id, n, pid|
			until(%x[docker logs --tail=3 #{id}].include? 'Aviarc startup complete')
				#blkio_service_bytes = IO.read("/sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_service_bytes").to_csv
				#blkio_serviced = IO.read("/sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_serviced").to_csv
				#blkio_queued = IO.read("/sys/fs/cgroup/blkio/system.slice/docker-#{id}.scope/blkio.io_queued").to_csv
        #proc_status = `grep -Po "(?<=State:\t)[A-Z]" /proc/#{pid}/status`.chomp
        cpu_split = IO.read("/sys/fs/cgroup/cpu/system.slice/docker-#{id}.scope/cpuacct.stat").to_csv
        cpu_usage = IO.read("/sys/fs/cgroup/cpu/system.slice/docker-#{id}.scope/cpuacct.usage").to_csv
        proc_io = IO.read("/proc/#{pid}/io").to_csv
        mem = IO.readlines("/sys/fs/cgroup/memory/system.slice/docker-#{id}.scope/memory.stat")[1].to_csv

				File.open("tests/#{run}/#{herd_name}#{n}.csv", "a") do |f|
					# Write headerline on first run.
    			f.puts "timestamp,cpu_user,cpu_system,cpu_time,rchar,wchar,syscr,syscw,rbytes,wbytes,cbytes,rss" if f.size == 0
					time = Time.now.strftime "%-m/%-d %H:%M:%S.%L"
					f.puts "#{time},#{cpu_split},#{cpu_usage},#{proc_io},#{mem}"
				end
			end
			puts "Thread #{n} exited."
		}
	end
	
	# Wait for all threads to finish.
	threads.each {|t| t.join}
  puts "Benchmarking complete."
  sleep 5
  
  PostProcess.new.execute(run)
  
end

# Build an image from dockerfile.
def build
	image_name = ARGV[1]
	docker_file_path = ARGV[2]

	cmd = "docker build --rm=true --tag=\"#{image_name}\" #{docker_file_path}"
	puts "Building image..."
	`#{cmd}`
	puts cmd
end

# Clean all docker containers.
def clean
 puts "Cleaning herds..."
 File.open(@file, 'w') {}
 %x[docker rm -f `docker ps --no-trunc -aq`]
end

# Instantiate a herd of docker containers.
def create
	image = ARGV[1]
	size = ARGV[2].to_i
	run_args = ARGV.drop(3).join(" ")
	
	# Convert image name to herd name.
	friendly_name = image
	friendly_name = /(?<=\/)\w+\b/.match(image).to_s if image.include?("/")
	herd_name = friendly_name + "s"

	# Create herd data.
	@herds[herd_name] = Hash["size" => size, "ids" => Array.new]

	puts "Creating herd..."
	size.times do |n|
		cmd = "docker create --restart=always --name #{friendly_name}#{n} #{image} #{run_args}"
		@herds[herd_name]["ids"][n] = `#{cmd}`
		puts cmd
	end
	commit_data
end

# Run a command against a herd.
def run
	herd_name = ARGV[1]
	cmd = "docker " << ARGV[2]
	args = ARGV.drop(3).join(" ")
	
	unless @herds[herd_name]
		puts "No herd exists with name: '#{herd_name}'"
		return
	end

	@herds[herd_name]["ids"].each do |id|
	  `#{cmd} #{id} #{args}`
		puts "#{cmd} #{id} #{args}"
	end
end

# Write herd data to file for persistence.
def commit_data
	File.open(@file, 'w') { |file| YAML.dump(@herds, file)  }
end

# Load herd data from file.
# If file is blank or missing - intialise new hash instead.
def load_data
	if File.exists?(@file) and not File.zero?(@file)
		@herds = YAML.load_file("data.yaml") 
	else
		@herds = Hash.new
	end
end

# Print help commands.
def help
	puts "
 ___________
 < Herder >
 -----------
       \\   ^__^
        \\  (oo)\\_______
           (__)\\       )\\/\\
                ||----w |
                ||     ||"
	puts "Build a Dockerfile:"
	puts "  herder -b <repository/image_name> <path_to_dockerfile>"
	puts ""
	puts "Benchmark container startup:"
  puts " sudo herder --bench (<herd_name>|<image_name> <count>)"
  puts "<herd_name> will use an existing herd. <image_name> <count> will create a new herd."
  puts " *Requires root privilleges."
  puts "Clean all Docker containers:"
	puts "  herder --clean"
	puts ""
	puts "Create a new herd:"
	puts "  herder -c <repository/image_name> <count>"
	puts ""
	puts "List herds:"
	puts " herder -l"
	puts ""
	puts "Run command over a herd:"
  puts "  herder -r <herd_name> <docker_command>"
	puts ""
end

def list
	puts "Herds: "	
	@herds.keys.each do |h|
		puts " #{h}, size: #{@herds[h]["size"]}"
	end
end

def process 
	Dir.glob("./tests/*").each do |d|
		x = d.split("./tests/")[1]
		puts x
		PostProcess.new.execute(x)			
	end
end

##################
# Run the Script.#
##################
load_data
interperet
